`timescale 1ns / 1ps

module top (
    input clk,
    input rst,
    input [5:0] btn,
    input add_sel,
    output dac_csn,
    output dac_ldacn,
    output dac_wrn,
    output dac_a_b,
    output [7:0] dac_d,
    output [7:0] led_out,

    output [7:0] seg_data,
    output [7:0] seg_sel,

    output LCD_E,
    output LCD_RS,
    output LCD_RW,
    output [7:0] LCD_DATA
    );
    
    DAC u_dac(
        .clk(clk),
        .rst(rst),
        .btn(btn),
        .add_sel(add_sel),
        .dac_csn(dac_csn),
        .dac_ldacn(dac_ldacn),
        .dac_wrn(dac_wrn),
        .dac_a_b(dac_a_b),
        .dac_d(dac_d),
        .led_out(led_out)
    );

    text_LCD_dac u_lcd (
        .rst(rst),
        .clk(clk),
        .dac_in(dac_d),
        .LCD_E(LCD_E),
        .LCD_RS(LCD_RS),
        .LCD_RW(LCD_RW),
        .LCD_DATA(LCD_DATA)
    );

    seg_array u_seg(
        .clk(clk),
        .rst(rst),
        .dac_in(dac_d),
        .seg_data(seg_data),
        .seg_sel(seg_sel)
    );

endmodule


module DAC(
    input clk, 
    input rst,
    input [5:0] btn,
    input add_sel,
    output reg dac_csn,
    output reg dac_ldacn,
    output reg dac_wrn,
    output reg dac_a_b,
    output reg [7:0] dac_d,
    output reg [7:0] led_out
    );

    reg [7:0] dac_d_temp;
    reg [7:0] cnt;
    wire [5:0] btn_t;
    
    reg [1:0] state;
    
    parameter DELAY = 2'b00,
              SET_WRN = 2'b01,
              UP_DATA = 2'b10;
    
    oneshot #(.WIDTH(6)) O1(clk, rst, {btn[5:0]}, {btn_t[5:0]});
    
    always @(posedge clk or negedge rst) begin
        if(!rst) begin
            state <= DELAY;
        end
        else begin
            case(state)
                DELAY : if(cnt == 200) state <= SET_WRN;
                SET_WRN : if(cnt == 50) state <= UP_DATA;
                UP_DATA : if(cnt == 30) state <= DELAY;
            endcase
        end
    end
    
    
    always @(posedge clk or negedge rst) begin
        if(!rst)
            cnt <= 8'b0000_0000;
        else begin
            case(state)
                DELAY :begin if(cnt >= 200) cnt <= 0;
                else cnt <= cnt + 1;
                end
                SET_WRN : begin if(cnt >= 50) cnt <= 0;
                else cnt <= cnt + 1;
                end
                UP_DATA : begin if(cnt >= 30) cnt <= 0;
                else cnt <= cnt + 1;
                end
            endcase
        end
    end
    
    
    always @(posedge clk or negedge rst) begin
        if(!rst) begin
            dac_wrn <= 1;
        end
        else begin
            case(state)
                DELAY : dac_wrn <= 1;
                SET_WRN : dac_wrn <= 0;
                UP_DATA : dac_d <= dac_d_temp;
            endcase
        end
    end
    
    
    always @(posedge clk) begin
        if(!rst) begin
            dac_d_temp <= 8'b0000_0000;
            led_out <= 8'b0101_0101;
        end
        else begin
            if(btn_t == 6'b100000) dac_d_temp <= dac_d_temp - 8'b0000_0001;
            else if(btn_t == 6'b010000) dac_d_temp <= dac_d_temp + 8'b0000_0001;
            else if(btn_t == 6'b001000) dac_d_temp <= dac_d_temp - 8'b0000_0010;
            else if(btn_t == 6'b000100) dac_d_temp <= dac_d_temp + 8'b0000_0010;
            else if(btn_t == 6'b000010) dac_d_temp <= dac_d_temp - 8'b0000_1000;
            else if(btn_t == 6'b000001) dac_d_temp <= dac_d_temp + 8'b0000_1000;
    
            led_out <= dac_d_temp;
        end
    end
    
    
    always @(posedge clk) begin
        dac_csn <= 0;
        dac_ldacn <= 0;
        dac_a_b <= add_sel;
    end

endmodule

module oneshot #(parameter WIDTH = 1) (
    input clk,
    input rst,
    input [WIDTH-1:0] btn_in,
    output reg [WIDTH-1:0] btn_out
    );
    reg [WIDTH-1:0] btn_reg;
    
    always @(posedge clk or negedge rst) begin
        if(!rst) begin
            btn_reg <= 0;
            btn_out <= 0;
        end
        else begin
            btn_out <= btn_in & ~btn_reg; 
            btn_reg <= btn_in;
        end
    end
endmodule
/////textLCD

module text_LCD_dac(
    input rst,
    input clk,
    input [7:0] dac_in, 

    output LCD_E,
    output reg LCD_RS,
    output reg LCD_RW,
    output reg [7:0] LCD_DATA
);
    assign LCD_E = clk;
    
    reg [7:0] cnt;
    reg [2:0] state;
    reg [11:0] bcd_value;
    reg [7:0] dac_prev;

    parameter DELAY = 3'b000,
              FUNCTION_SET = 3'b001,
              DISP_ONOFF = 3'b010,
              ENTRY_MODE = 3'b011,
              SET_ADDRESS = 3'b100,
              DELAY_T = 3'b101,
              WRITE = 3'b110;
    
   
    integer a;
    integer hundred, ten, one;
    
    always @(posedge clk or negedge rst) begin
        if (!rst) begin
            bcd_value <= 12'd0;
            dac_prev <= 8'd0;
        end
        else begin
            a = dac_in;
            hundred = a / 100;
            a = a % 100;
            ten = a / 10;
            one = a % 10;
            
            bcd_value <= {hundred[3:0], ten[3:0], one[3:0]};
            dac_prev <= dac_in;
        end
    end

    // 상태 머신
    always @(posedge clk or negedge rst) begin
        if (!rst) begin
            state <= DELAY;
        end else begin
            case (state)
                DELAY:
                    if (cnt == 70)
                        state <= FUNCTION_SET;
                FUNCTION_SET:
                    if (cnt == 30)
                        state <= DISP_ONOFF;
                DISP_ONOFF:
                    if (cnt == 30)
                        state <= ENTRY_MODE;
                ENTRY_MODE:
                    if (cnt == 30)
                        state <= SET_ADDRESS;
                SET_ADDRESS:
                    if (cnt == 100)
                        state <= DELAY_T;
                DELAY_T:
                    state <= WRITE;
                WRITE:
                    if (cnt == 30)
                        state <= DELAY_T;
                default:
                    state <= DELAY;
            endcase
        end
    end

   
    always @(posedge clk or negedge rst) begin
        if (!rst)
            cnt <= 0;
        else begin
            case (state)
                DELAY: cnt <= (cnt >= 70)  ? 0 : cnt + 1;
                FUNCTION_SET: cnt <=(cnt >= 30)  ? 0 : cnt + 1;
                DISP_ONOFF: cnt <=(cnt >= 30)  ? 0 : cnt + 1;
                ENTRY_MODE: cnt <=(cnt >= 30)  ? 0 : cnt + 1;
                SET_ADDRESS: cnt <=(cnt >= 100) ? 0 : cnt + 1;
                DELAY_T:cnt <= 0;
                WRITE: cnt <= (cnt>= 30)  ? 0 : cnt + 1;
                default: cnt <= 0;
            endcase
        end
    end


    always @(posedge clk or negedge rst) begin
        if (!rst)
            {LCD_RS, LCD_RW, LCD_DATA} <= 10'b0_0_0000_0001;
        else begin
            case (state)
                
                FUNCTION_SET:
                    {LCD_RS, LCD_RW, LCD_DATA} <= 10'b0_0_0011_1000;               
                DISP_ONOFF:
                    {LCD_RS, LCD_RW, LCD_DATA} <= 10'b0_0_0000_1100;                
                ENTRY_MODE:
                    {LCD_RS, LCD_RW, LCD_DATA} <= 10'b0_0_0000_0110;                
                SET_ADDRESS:
                    {LCD_RS, LCD_RW, LCD_DATA} <= 10'b0_0_1000_0000;               
                DELAY_T:
                    {LCD_RS, LCD_RW, LCD_DATA} <= 10'b0_0_0000_1100;
                WRITE: begin
                    case (cnt)
                        8'd0:{LCD_RS, LCD_RW, LCD_DATA} <= 10'b0_0_1000_0000;
                        8'd1: {LCD_RS, LCD_RW, LCD_DATA} <= {2'b10, 4'b0011, bcd_value[11:8]};
                        8'd2: {LCD_RS, LCD_RW, LCD_DATA}<= {2'b10, 4'b0011, bcd_value[7:4]};
                        8'd3: {LCD_RS, LCD_RW, LCD_DATA} <= {2'b10, 4'b0011, bcd_value[3:0]};
                        default:
                            {LCD_RS, LCD_RW, LCD_DATA} <= 10'b0_0_0000_1100;
                    endcase
                end
                default:
                    {LCD_RS, LCD_RW, LCD_DATA} <= 10'b0_0_0000_1100;
            endcase
        end
    end
    
endmodule


/////////////seg_array

module seg_array(
    input clk,
    input rst,
    input [7:0] dac_in,
    output reg [7:0] seg_data,
    output reg [7:0] seg_sel
    );
    
    wire [11:0] dac_bcd;
    reg [3:0] bcd;
    
    bin2bcd B1(clk, rst, dac_in[7:0], dac_bcd[11:0]);
    
    always @(posedge clk or negedge rst) begin
        if (!rst) 
            seg_sel <= 8'b11111110;
        else begin
            seg_sel <= {seg_sel[6:0], seg_sel[7]};
        end
    end
    
    always @(*) begin
        case (bcd[3:0])
            0 : seg_data = 8'b11111100;
            1 : seg_data = 8'b01100000;
            2 : seg_data = 8'b11011010;
            3 : seg_data = 8'b11110010;
            4 : seg_data = 8'b01100110;
            5 : seg_data = 8'b10110110;
            6 : seg_data = 8'b10111110;
            7 : seg_data = 8'b11100000;
            8 : seg_data = 8'b11111110;
            9 : seg_data = 8'b11110110;
            default : seg_data = 8'b00000000;
        endcase
    end
    
    always @(*) begin
        case (seg_sel)
            8'b11111110 : bcd = dac_bcd[3:0];
            8'b11111101 : bcd = dac_bcd[7:4];
            8'b11111011 : bcd = dac_bcd[11:8];
            default : bcd = 4'b0000;
        endcase
    end
endmodule
    
module bin2bcd (
        input clk,
        input rst,
        input [7:0] bin,      
        output reg [11:0] bcd_out  
        );
        integer a;
        integer hundred, ten, one;
        always @(posedge clk or negedge rst) begin
            if (!rst) begin
                bcd_out <= 12'd0;
            end
            else begin
                a = bin;
                hundred = a/100;
                a = a%100;
                ten = a/10;
                one = a%10;
                bcd_out <= {hundred[3:0], ten[3:0], one[3:0]};
            end
        end
endmodule




