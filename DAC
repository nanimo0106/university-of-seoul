`timescale 1ns / 1ps

module top (
    input clk,
    input rst,
    input [5:0] btn,
    input add_sel,
    output dac_csn,
    output dac_ldacn,
    output dac_wrn,
    output dac_a_b,
    output [7:0] dac_d,

    output [7:0] led_out_dac,
    output [7:0] led_out_lcd,

    output [7:0] seg_data,
    output [7:0] seg_sel,

    output LCD_E,
    output LCD_RS,
    output LCD_RW,
    output [7:0] LCD_DATA
    );
    
    DAC u_dac(
        .clk(clk),
        .rst(rst),
        .btn(btn),
        .add_sel(add_sel),
        .dac_csn(dac_csn),
        .dac_ldacn(dac_ldacn),
        .dac_wrn(dac_wrn),
        .dac_a_b(dac_a_b),
        .dac_d(dac_d),
        .led_out(led_out_dac)
    );

    text_LCD_dac u_lcd (
        .rst(rst),
        .clk(clk),
        .dac_in(dac_d),
        .LCD_E(LCD_E),
        .LCD_RS(LCD_RS),
        .LCD_RW(LCD_RW),
        .LCD_DATA(LCD_DATA),
        .LED_out(led_out_lcd)
    );

    seg_array u_seg(
        .clk(clk),
        .rst(rst),
        .dac_in(dac_d),
        .seg_data(seg_data),
        .seg_sel(seg_sel)
    );

endmodule


module DAC(
    input clk, 
    input rst,
    input [5:0] btn,
    input add_sel,
    output reg dac_csn,
    output reg dac_ldacn,
    output reg dac_wrn,
    output reg dac_a_b,
    output reg [7:0] dac_d,
    output reg [7:0] led_out
    );

reg [7:0] dac_d_temp;
reg [7:0] cnt;
wire [5:0] btn_t;

reg [1:0] state;

parameter DELAY = 2'b00,
          SET_WRN = 2'b01,
          UP_DATA = 2'b10;

oneshot #(.WIDTH(6)) O1(clk, rst, {btn[5:0]}, {btn_t[5:0]});

always @(posedge clk or negedge rst) begin
    if(!rst) begin
        state <= DELAY;
    end
    else begin
        case(state)
            DELAY : if(cnt == 200) state <= SET_WRN;
            SET_WRN : if(cnt == 50) state <= UP_DATA;
            UP_DATA : if(cnt == 30) state <= DELAY;
        endcase
    end
end


always @(posedge clk or negedge rst) begin
    if(!rst)
        cnt <= 8'b0000_0000;
    else begin
        case(state)
            DELAY :begin if(cnt >= 200) cnt <= 0;
            else cnt <= cnt + 1;
            end
            SET_WRN : begin if(cnt >= 50) cnt <= 0;
            else cnt <= cnt + 1;
            end
            UP_DATA : begin if(cnt >= 30) cnt <= 0;
            else cnt <= cnt + 1;
            end
        endcase
    end
end


always @(posedge clk or negedge rst) begin
    if(!rst) begin
        dac_wrn <= 1;
    end
    else begin
        case(state)
            DELAY : dac_wrn <= 1;
            SET_WRN : dac_wrn <= 0;
            UP_DATA : dac_d <= dac_d_temp;
        endcase
    end
end


always @(posedge clk) begin
    if(!rst) begin
        dac_d_temp <= 8'b0000_0000;
        led_out <= 8'b0101_0101;
    end
    else begin
        if(btn_t == 6'b100000) dac_d_temp <= dac_d_temp - 8'b0000_0001;
        else if(btn_t == 6'b010000) dac_d_temp <= dac_d_temp + 8'b0000_0001;
        else if(btn_t == 6'b001000) dac_d_temp <= dac_d_temp - 8'b0000_0010;
        else if(btn_t == 6'b000100) dac_d_temp <= dac_d_temp + 8'b0000_0010;
        else if(btn_t == 6'b000010) dac_d_temp <= dac_d_temp - 8'b0000_1000;
        else if(btn_t == 6'b000001) dac_d_temp <= dac_d_temp + 8'b0000_1000;

        led_out <= dac_d_temp;
    end
end


always @(posedge clk) begin
    dac_csn <= 0;
    dac_ldacn <= 0;
    dac_a_b <= add_sel;
end

endmodule

module oneshot #(parameter WIDTH = 1) (
    input clk,
    input rst,
    input [WIDTH-1:0] btn_in,
    output reg [WIDTH-1:0] btn_out
    );
    reg [WIDTH-1:0] btn_reg;
    
    always @(posedge clk or negedge rst) begin
        if(!rst) begin
            btn_reg <= 0;
            btn_out <= 0;
        end
        else begin
            btn_out <= btn_in & ~btn_reg; 
            btn_reg <= btn_in;
        end
    end
endmodule
//////////////////////text_lcd

module text_LCD_dac(
    input rst,
    input clk,
    input [7:0] dac_in, 

    output LCD_E,
    output reg LCD_RS,
    output reg LCD_RW,
    output reg [7:0] LCD_DATA,
    output reg [7:0] LED_out
    );
       
    assign LCD_E = clk;

    reg [2:0] state;

    parameter
    DELAY = 3'b000,
    FUNCTION_SET = 3'b001,
    ENTRY_MODE = 3'b010,
    DISP_ONOFF = 3'b011,
    LINE1 = 3'b100,
    LINE2 = 3'b101,
    DELAY_T = 3'b110,
    CLEAR_DISP = 3'b111;

    integer cnt;
    
always @(posedge clk or negedge rst) begin
    if(!rst)
        {LCD_RS, LCD_RW, LCD_DATA} = 10'b1_1_00000000;
    else begin
        case(state)
            FUNCTION_SET : {LCD_RS, LCD_RW, LCD_DATA} = 10'b0_0_00110000; 
            DISP_ONOFF : {LCD_RS, LCD_RW, LCD_DATA} = 10'b0_0_00001100; 
            ENTRY_MODE : {LCD_RS, LCD_RW, LCD_DATA} = 10'b0_0_00000110; 
            LINE1 : begin
                case(cnt)
                    00: {LCD_RS, LCD_RW, LCD_DATA} = 10'b0_0_10000000; // address 0
                    01: {LCD_RS, LCD_RW, LCD_DATA} = {1'b1, 1'b0, 8'b00110000 + (dac_in / 100)}; // hundred
                    02: {LCD_RS, LCD_RW, LCD_DATA} = {1'b1, 1'b0, 8'b00110000 + ((dac_in % 100) / 10)}; // ten
                    03: {LCD_RS, LCD_RW, LCD_DATA} = {1'b1, 1'b0, 8'b00110000 + (dac_in % 10)}; // one
                    default: {LCD_RS, LCD_RW, LCD_DATA} = 10'b1_0_00100000;
                endcase
            end
            LINE2 : begin // no use!
                case(cnt)
                    00: {LCD_RS, LCD_RW, LCD_DATA} = 10'b0_0_11000000; // address 40
                    01: {LCD_RS, LCD_RW, LCD_DATA} = 10'b1_0_00110010; // 2
                    02: {LCD_RS, LCD_RW, LCD_DATA} = 10'b1_0_00110000; // 0
                    03: {LCD_RS, LCD_RW, LCD_DATA} = 10'b1_0_00110010; // 2
                    04: {LCD_RS, LCD_RW, LCD_DATA} = 10'b1_0_00110001; // 1
                    05: {LCD_RS, LCD_RW, LCD_DATA} = 10'b1_0_00110100; // 4
                    06: {LCD_RS, LCD_RW, LCD_DATA} = 10'b1_0_00110100; // 4
                    07: {LCD_RS, LCD_RW, LCD_DATA} = 10'b1_0_00110000; // 0
                    08: {LCD_RS, LCD_RW, LCD_DATA} = 10'b1_0_00110000; // 0
                    09: {LCD_RS, LCD_RW, LCD_DATA} = 10'b1_0_00110110; // 6
                    10: {LCD_RS, LCD_RW, LCD_DATA} = 10'b1_0_00110000; // 0
                    11: {LCD_RS, LCD_RW, LCD_DATA} = 10'b1_0_00100000; // space
                    12: {LCD_RS, LCD_RW, LCD_DATA} = 10'b1_0_01010011; // S
                    13: {LCD_RS, LCD_RW, LCD_DATA} = 10'b1_0_01001101; // M
                    14: {LCD_RS, LCD_RW, LCD_DATA} = 10'b1_0_01001000; // H
                    default: {LCD_RS, LCD_RW, LCD_DATA} = 10'b1_0_00100000;
                endcase
            end
            DELAY_T : {LCD_RS, LCD_RW, LCD_DATA} = 10'b0_0_00000000; 
            CLEAR_DISP : {LCD_RS, LCD_RW, LCD_DATA} = 10'b0_0_00000001;
            default : {LCD_RS, LCD_RW, LCD_DATA} = 10'b1_0_00000000;
        endcase
    end
end

    always @(posedge clk or negedge rst) begin
        if(!rst)
            cnt <= 0;
        else begin
            case(state) 
                DELAY : if(cnt >= 70) cnt <= 0;  else cnt <= cnt + 1;
                FUNCTION_SET: if(cnt >= 30) cnt <= 0;  else cnt <= cnt + 1;
                DISP_ONOFF : if(cnt >= 30) cnt <= 0;  else cnt <= cnt + 1;
                ENTRY_MODE : if(cnt >= 30) cnt <= 0;  else cnt <= cnt + 1;
                LINE1 : if(cnt >= 20) cnt <= 0;  else cnt <= cnt + 1;
                LINE2 : if(cnt >= 20) cnt <= 0;  else cnt <= cnt + 1;
                DELAY_T : if(cnt >= 5)  cnt <= 0;  else cnt <= cnt + 1;
                CLEAR_DISP : if(cnt >= 5)  cnt <= 0;  else cnt <= cnt + 1;
                default : cnt <= 0;
            endcase
        end
    end
always @(posedge clk or negedge rst) begin
    if(!rst)
        state = DELAY;
    else begin
        case(state)
            DELAY: begin
                LED_out = 8'b1000_0000;
                if(cnt == 70) state = FUNCTION_SET;
            end
            FUNCTION_SET: begin
                LED_out = 8'b0100_0000;
                if(cnt == 30) state = DISP_ONOFF;
            end
            DISP_ONOFF: begin
                LED_out = 8'b0010_0000;
                if(cnt == 30) state = ENTRY_MODE;
            end
            ENTRY_MODE: begin
                LED_out = 8'b0001_0000;
                if(cnt == 30) state = LINE1;
            end
            LINE1: begin
                LED_out = 8'b0000_1000;
                if(cnt == 20) state = LINE2;
            end
            LINE2: begin
                LED_out = 8'b0000_0100;
                if(cnt == 20) state = DELAY_T;
            end
            DELAY_T: begin
                LED_out = 8'b0000_0010;
                if(cnt == 5) state = CLEAR_DISP;
            end
            CLEAR_DISP: begin
                LED_out = 8'b0000_0001;
                if(cnt == 5) state = LINE1;
            end
            default: state = DELAY;
        endcase
    end
end
endmodule

/////////////seg_array

module seg_array(
    input clk,
    input rst,
    input [7:0] dac_in,
    output reg [7:0] seg_data,
    output reg [7:0] seg_sel
    );

wire [11:0] dac_bcd;
reg [3:0] bcd;

bin2bcd B1(clk, rst, dac_in[7:0], dac_bcd[11:0]);

always @(posedge clk or negedge rst) begin
    if (!rst) 
        seg_sel <= 8'b11111110;
    else begin
        seg_sel <= {seg_sel[6:0], seg_sel[7]};
    end
end

always @(*) begin
    case (bcd[3:0])
        0 : seg_data = 8'b11111100;
        1 : seg_data = 8'b01100000;
        2 : seg_data = 8'b11011010;
        3 : seg_data = 8'b11110010;
        4 : seg_data = 8'b01100110;
        5 : seg_data = 8'b10110110;
        6 : seg_data = 8'b10111110;
        7 : seg_data = 8'b11100000;
        8 : seg_data = 8'b11111110;
        9 : seg_data = 8'b11110110;
        default : seg_data = 8'b00000000;
    endcase
end

always @(*) begin
    case (seg_sel)
        8'b11111110 : bcd = dac_bcd[3:0];
        8'b11111101 : bcd = dac_bcd[7:4];
        8'b11111011 : bcd = dac_bcd[11:8];
        default : bcd = 4'b0000;
    endcase
end

endmodule


module bin2bcd (
    input clk,
    input rst,
    input [7:0] bin,      
    output reg [11:0] bcd_out  
    );
    integer a;
    integer hundred, ten, one;

    always @(posedge clk or negedge rst) begin
        if (!rst) begin
            bcd_out <= 12'd0;
        end
        else begin
            a = bin;
            hundred = a/100;
            a = a%100;
            ten = a/10;
            one = a%10;

            bcd_out <= {hundred[3:0], ten[3:0], one[3:0]};
        end
    end
endmodule




